1- golang的教程，还没有结束啊
    https://www.bilibili.com/video/BV1bp4y1x7Th?p=8&vd_source=6ccda088f124d39971be265ef3ed268f
2-
    pnpm init
    新 建 yaml 文件

    // 这样才可以把包安装到根目录
    pnpm install vue -w

3- 环境搭建
    vue3 源码开发环境 esbuild 生产环境rollup（rollup更适合类库的打包）

    打包的结果
        iife立即执行函数，将结果定义到全局变量上（umd是为了支持amd的语法）
        esmodule：
            esm-bundler: 并不会将模块打包到一起，主要是在工程化之中使用

            esm-browser: type="module" 在浏览器之中可以通过type=module来进行使用的模块，会将所有的模块打包到一起，可以直接使用

            commonjs：cjs 主要是给node来使用的，node之中的mjs也是向esm发展的

    vue3之中采用的monorepo的方式进行了仓库管理 pnpm
        模块的打包格式和项目的搭建的方式

    vue3的核心模块 reactivity
        proxy替换掉了defineProxy
        compositionApi

    面试题：
        compositionApi 和 optionsApi 对比的优势
            按需导入，提供了复用性
            optionsApi 反复横跳

        reactivity 内部提供的api都是核心的 compositionApi

        reactive （proxy 对对象增加了get set拦截）

        ref （defineProxy）

        reactive 和 ref 的区别
            ref放的是对象 会走 reactive

        shallowReactive:
        shallowRef:
        readonly: 属性就丧失了依赖的收集能力
        shallowReadonly:

        toRaw 通过代理后的结果，返回原值
        markRaw
        effect 是 vue的一个核心 computed watch watchEffect
        computed 和 watch的区别：
            计算属性和缓存值，
            watch就是数据变化就是回调：可以监控响应式的数据

            flush: 'sync'
        计算属性主要就是缓存

        watch watchEffect 的 区别

    依赖收集：
        track map 映射表来维护数据和effect的关系
        trigger 通过属性来触发effect来执行


    effect的清理操作
        stop run 让effect再次运行 == forceUpdate
        stop 停止依赖收集

        isReactive

        isReadonly

        isRef

        isProxy

        toRef

        toRefs({})

        proxyRefs() 将ref转换为代理的方式进行访问

        渲染相关的

        runtime-dom
        runtime-core

    vue3的组成 编译时（compiler-dom complier-core） 运行时(runtime-dom runtime-core reactivity)


    runtime-dom: 提供了上层的api
        createRenderer()
        render()

        内部封装了dom操作的api  patchProps
        最终将方法提供给runtime-core 来使用

    runtime-core 不依赖于平台的，虚拟dom
    h()
    儿子有3种：文本 数组 null
    createVNode(类型，属性，儿子)

    通过上层传递的api进行渲染，递归渲染，patch

    vue之中如何将虚拟节点转换为真实节点：遍历对象，根据对象的类型，属性 儿子


    卸载的问题：
        render(null) 卸载元素
    更新的问题：
        patch方法 包含了更新和初始化的方法

    diff元素：
        之前和之后的元素不是同一个节点
        删除老得，创建新的
    diff算法默认是平级比较
    全量比对：
        tag key 有一个不一样，就是同一个
    是同一个节点，会复用节点，之后更新属性和儿子

    儿子的更新有9种方式
        文本 数组 null * 文本 数组 null

    双方儿子都是数组的情况：
        同序列比较：
            向前追加和向后追加 from start from end
            sync from start sync from end
            挂载 卸载

        确定两个序列之中的变化的部分
        vue3之中，采用的是根据新节点来创建映射表，使用老的去找，没有的话就删除，
        有的话就会复用比较属性和儿子

    .vue template -> render 函数 就是编译时 耗费性能，放在工程化里面进行转化

    运行时： 直接的render函数，不关心把模版转换为render函数


    createApp



    effect
    {
        {}: {
            "key1": set[effect1, effect2]
        }
    }


















